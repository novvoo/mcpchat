// Initialize embeddings_config table and sync configuration
const { Pool } = require('pg');
const fs = require('fs');
const path = require('path');

async function initEmbeddingsConfigTable() {
    console.log('üöÄ ÂàùÂßãÂåñ embeddings_config Ë°®...\n');

    // Âä†ËΩΩÊï∞ÊçÆÂ∫ìÈÖçÁΩÆ
    const dbConfigPath = path.join(process.cwd(), 'config', 'database.json');
    if (!fs.existsSync(dbConfigPath)) {
        console.error('‚ùå Êï∞ÊçÆÂ∫ìÈÖçÁΩÆÊñá‰ª∂‰∏çÂ≠òÂú®:', dbConfigPath);
        process.exit(1);
    }

    const configData = JSON.parse(fs.readFileSync(dbConfigPath, 'utf-8'));
    const dbConfig = configData.postgresql;

    const pool = new Pool({
        host: dbConfig.host,
        port: dbConfig.port,
        database: dbConfig.database,
        user: dbConfig.user,
        password: dbConfig.password,
        ssl: dbConfig.ssl ? { rejectUnauthorized: false } : false
    });

    const client = await pool.connect();

    try {
        console.log('‚úì ËøûÊé•Êï∞ÊçÆÂ∫ìÊàêÂäü\n');

        // 1. ÂàõÂª∫ embeddings_config Ë°®
        console.log('1Ô∏è‚É£ ÂàõÂª∫ embeddings_config Ë°®...');
        await client.query(`
            CREATE TABLE IF NOT EXISTS embeddings_config (
                id SERIAL PRIMARY KEY,
                provider VARCHAR(100) NOT NULL,
                model VARCHAR(255) NOT NULL,
                dimensions INTEGER NOT NULL,
                endpoint VARCHAR(255) NOT NULL,
                api_key_configured BOOLEAN DEFAULT false,
                base_url TEXT,
                batch_size INTEGER DEFAULT 100,
                is_available BOOLEAN DEFAULT false,
                last_checked TIMESTAMP,
                last_success TIMESTAMP,
                last_failure TIMESTAMP,
                failure_count INTEGER DEFAULT 0,
                success_count INTEGER DEFAULT 0,
                fallback_enabled BOOLEAN DEFAULT true,
                fallback_type VARCHAR(50) DEFAULT 'mock',
                metadata JSONB,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        `);
        console.log('‚úì embeddings_config Ë°®ÂàõÂª∫ÊàêÂäü\n');

        // 2. ÂàõÂª∫Á¥¢Âºï
        console.log('2Ô∏è‚É£ ÂàõÂª∫Á¥¢Âºï...');
        await client.query(`
            CREATE INDEX IF NOT EXISTS embeddings_config_provider_idx 
            ON embeddings_config (provider)
        `);
        console.log('‚úì Á¥¢ÂºïÂàõÂª∫ÊàêÂäü\n');

        // 3. ÂêåÊ≠•ÈÖçÁΩÆÊñá‰ª∂Âà∞Êï∞ÊçÆÂ∫ì
        console.log('3Ô∏è‚É£ ÂêåÊ≠• embeddings ÈÖçÁΩÆÂà∞Êï∞ÊçÆÂ∫ì...');
        const embeddingsConfigPath = path.join(process.cwd(), 'config', 'embeddings.json');
        
        if (!fs.existsSync(embeddingsConfigPath)) {
            console.warn('‚ö†Ô∏è  embeddings.json ‰∏çÂ≠òÂú®ÔºåÂàõÂª∫ÈªòËÆ§ÈÖçÁΩÆËÆ∞ÂΩï');
            await client.query(`
                INSERT INTO embeddings_config (
                    provider, model, dimensions, endpoint, api_key_configured,
                    base_url, batch_size, is_available, fallback_enabled, fallback_type
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                ON CONFLICT DO NOTHING
            `, [
                'openai',
                'text-embedding-ada-002',
                1536,
                '/embeddings',
                false,
                null,
                100,
                false,
                true,
                'mock'
            ]);
        } else {
            const embeddingsConfig = JSON.parse(fs.readFileSync(embeddingsConfigPath, 'utf-8'));
            
            // Ëé∑Âèñ LLM ÈÖçÁΩÆ
            const baseUrl = process.env.LLM_URL || null;
            const apiKeyConfigured = !!(process.env.LLM_API_KEY);

            // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÊúâËÆ∞ÂΩï
            const existing = await client.query('SELECT id FROM embeddings_config LIMIT 1');
            
            if (existing.rows.length > 0) {
                // Êõ¥Êñ∞Áé∞ÊúâËÆ∞ÂΩï
                await client.query(`
                    UPDATE embeddings_config 
                    SET provider = $1,
                        model = $2,
                        dimensions = $3,
                        endpoint = $4,
                        api_key_configured = $5,
                        base_url = $6,
                        batch_size = $7,
                        fallback_enabled = $8,
                        fallback_type = $9,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE id = $10
                `, [
                    embeddingsConfig.provider || 'openai',
                    embeddingsConfig.model || 'text-embedding-ada-002',
                    embeddingsConfig.dimensions || 1536,
                    embeddingsConfig.endpoint || '/embeddings',
                    apiKeyConfigured,
                    baseUrl,
                    embeddingsConfig.batchSize || 100,
                    embeddingsConfig.fallback?.enabled ?? true,
                    embeddingsConfig.fallback?.type || 'mock',
                    existing.rows[0].id
                ]);
                console.log('‚úì ÈÖçÁΩÆÂ∑≤Êõ¥Êñ∞');
            } else {
                // ÊèíÂÖ•Êñ∞ËÆ∞ÂΩï
                await client.query(`
                    INSERT INTO embeddings_config (
                        provider, model, dimensions, endpoint, api_key_configured,
                        base_url, batch_size, is_available, fallback_enabled, fallback_type
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                `, [
                    embeddingsConfig.provider || 'openai',
                    embeddingsConfig.model || 'text-embedding-ada-002',
                    embeddingsConfig.dimensions || 1536,
                    embeddingsConfig.endpoint || '/embeddings',
                    apiKeyConfigured,
                    baseUrl,
                    embeddingsConfig.batchSize || 100,
                    false,
                    embeddingsConfig.fallback?.enabled ?? true,
                    embeddingsConfig.fallback?.type || 'mock'
                ]);
                console.log('‚úì ÈÖçÁΩÆÂ∑≤ÊèíÂÖ•');
            }
        }
        console.log('‚úì ÈÖçÁΩÆÂêåÊ≠•ÂÆåÊàê\n');

        // 4. ÊµãËØï embeddings ÂèØÁî®ÊÄß
        console.log('4Ô∏è‚É£ ÊµãËØï embeddings API ÂèØÁî®ÊÄß...');
        const config = await client.query('SELECT * FROM embeddings_config ORDER BY id DESC LIMIT 1');
        
        if (config.rows.length > 0 && config.rows[0].base_url) {
            const embConfig = config.rows[0];
            const baseUrl = embConfig.base_url.replace('/v1', '') + '/v1';
            const url = `${baseUrl}${embConfig.endpoint}`;
            
            const headers = {
                'Content-Type': 'application/json'
            };
            
            if (embConfig.api_key_configured && process.env.LLM_API_KEY) {
                headers['Authorization'] = `Bearer ${process.env.LLM_API_KEY}`;
            }

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);

                const response = await fetch(url, {
                    method: 'POST',
                    headers,
                    body: JSON.stringify({
                        input: 'test',
                        model: embConfig.model
                    }),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const responseText = await response.text();
                
                if (response.ok && responseText.trim().startsWith('{')) {
                    const data = JSON.parse(responseText);
                    if (data.data && data.data[0] && data.data[0].embedding) {
                        console.log('‚úì Embeddings API ÂèØÁî®');
                        await client.query(`
                            UPDATE embeddings_config 
                            SET is_available = true,
                                last_checked = CURRENT_TIMESTAMP,
                                last_success = CURRENT_TIMESTAMP,
                                updated_at = CURRENT_TIMESTAMP
                            WHERE id = $1
                        `, [embConfig.id]);
                    } else {
                        console.warn('‚ö†Ô∏è  Embeddings API ËøîÂõûÊ†ºÂºèÂºÇÂ∏∏');
                        await client.query(`
                            UPDATE embeddings_config 
                            SET is_available = false,
                                last_checked = CURRENT_TIMESTAMP,
                                last_failure = CURRENT_TIMESTAMP,
                                metadata = jsonb_set(COALESCE(metadata, '{}'::jsonb), '{error}', '"Unexpected response format"'),
                                updated_at = CURRENT_TIMESTAMP
                            WHERE id = $1
                        `, [embConfig.id]);
                    }
                } else {
                    console.warn('‚ö†Ô∏è  Embeddings API ‰∏çÂèØÁî®ÊàñËøîÂõûÈùû JSON');
                    await client.query(`
                        UPDATE embeddings_config 
                        SET is_available = false,
                            last_checked = CURRENT_TIMESTAMP,
                            last_failure = CURRENT_TIMESTAMP,
                            metadata = jsonb_set(COALESCE(metadata, '{}'::jsonb), '{error}', '"Non-JSON response"'),
                            updated_at = CURRENT_TIMESTAMP
                        WHERE id = $1
                    `, [embConfig.id]);
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è  Embeddings API ÊµãËØïÂ§±Ë¥•:', error.message);
                await client.query(`
                    UPDATE embeddings_config 
                    SET is_available = false,
                        last_checked = CURRENT_TIMESTAMP,
                        last_failure = CURRENT_TIMESTAMP,
                        metadata = jsonb_set(COALESCE(metadata, '{}'::jsonb), '{error}', $2),
                        updated_at = CURRENT_TIMESTAMP
                    WHERE id = $1
                `, [embConfig.id, JSON.stringify(error.message)]);
            }
        } else {
            console.warn('‚ö†Ô∏è  Êó†Ê≥ïÊµãËØïÔºöÁº∫Â∞ëÈÖçÁΩÆÊàñ base_url');
        }

        // 5. ÊòæÁ§∫ÊúÄÁªàÁä∂ÊÄÅ
        console.log('\n5Ô∏è‚É£ ÂΩìÂâçÈÖçÁΩÆÁä∂ÊÄÅ:');
        const finalConfig = await client.query('SELECT * FROM embeddings_config ORDER BY id DESC LIMIT 1');
        if (finalConfig.rows.length > 0) {
            const cfg = finalConfig.rows[0];
            console.log(`  Provider: ${cfg.provider}`);
            console.log(`  Model: ${cfg.model}`);
            console.log(`  Is Available: ${cfg.is_available ? '‚úì Yes' : '‚úó No'}`);
            console.log(`  Last Checked: ${cfg.last_checked || 'Never'}`);
            console.log(`  Fallback Enabled: ${cfg.fallback_enabled ? 'Yes' : 'No'}`);
        }

        console.log('\n‚úÖ embeddings_config Ë°®ÂàùÂßãÂåñÂÆåÊàêÔºÅ');

    } catch (error) {
        console.error('\n‚ùå ÂàùÂßãÂåñÂ§±Ë¥•:', error.message);
        console.error(error);
        process.exit(1);
    } finally {
        client.release();
        await pool.end();
    }
}

initEmbeddingsConfigTable();
